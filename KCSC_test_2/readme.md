# KCSC_test

## Over view

File PE32

![image](https://user-images.githubusercontent.com/87138860/224772198-57112f29-1c47-4585-8835-5f902d590d1e.png)

## Reverse

Load file vào ida để xem code

![image](https://user-images.githubusercontent.com/87138860/224772851-8722c4ff-b595-4062-a06a-6589291c3313.png)

Ta có thể thấy chương trình là một socket client. Nó sử dụng Winsock Api để thiết lập kết nối đến địa chỉ ip `127.0.0.1` và một cổng cụ thể nào đó và gửi dữ liệu qua kết nối
Ta cần nhập `input` có độ dài < 50 cho server để check.
Việc ta cần làm bây giờ là tìm server để xem hàm check.

![image](https://user-images.githubusercontent.com/87138860/224776155-37bee232-8329-41db-83f4-cb79b42bd1c9.png)

tại hàm `sub_901000` chương trình tìm kiếm tài nguyên có tên `BINARY` trong tệp đang thực thi bằng hàm `FindResourceA()`, sau đó sử dụng hàm `LoadResource()` để tải tài nguyên đó lên hệ thống. Sau đó, hàm `LockResource()` được sử dụng để khóa tài nguyên trong bộ nhớ để chúng ta có thể truy cập nó.
Sau đó, chương trình tính toán kích thước của tài nguyên sử dụng hàm `SizeofResource()` và cấp phát bộ nhớ động đủ lớn để lưu trữ tài nguyên. Tài nguyên được sao chép từ vùng nhớ đã khóa bằng hàm `memmove()` và được giải mã bằng cách thực hiện `XOR` với chỉ số của từng byte.
Tiếp theo, chương trình tạo một tệp tạm thời bằng cách sử dụng hàm `GetTempPathA()` và `GetTempFileNameA()`, sau đó mở tệp đó và ghi nội dung của tài nguyên đã được giải mã vào tệp đó bằng hàm `WriteFile()`. Cuối cùng, tệp tạm thời được đóng bằng hàm `CloseHandle()`.

![image](https://user-images.githubusercontent.com/87138860/224780819-05fcfb7f-b0f5-4ee6-8baf-a6382725270e.png)

Debug ngay dưới vòng for ta sẽ có được giá trị của `v3`. Sau đó ta đưa dữ liệu thu được vào `HxD` và lưu ta sẽ được chương trình Server.

Tiếp tục load chương trình vừa thu được vào ida.

![image](https://user-images.githubusercontent.com/87138860/224781400-ad19859c-a1ed-4dc0-8f65-fdd492af34b8.png)

Ta thấy hàm sử lý chuỗi thu được là ` sub_4026A8()`

![image](https://user-images.githubusercontent.com/87138860/224782724-fc55a8dc-9dae-4205-92cf-6530f8c12477.png)

Có thể thấy hàm `sub_4028C0()` sẽ xử lý dữ liệu `flag` và lưu vào `str`. Sau đó hàm `sub_40264C()` sẽ kiểm tra dữ liệu trong `str` xem giữ liệu thu được có đúng không.

Đầu tiên ta kiểm tra hàm `sub_4028C0()` 

![image](https://user-images.githubusercontent.com/87138860/224784103-9b12d3b0-8995-47d6-9d13-eca1f815acd8.png)


![image](https://user-images.githubusercontent.com/87138860/224783781-be0f7071-a238-413a-9976-c75c4ad5f3ae.png)

Hàm `sub_402808()` sẽ khởi tạo giá trị mảng `v3`

![image](https://user-images.githubusercontent.com/87138860/224784510-0abf2bd1-e3fe-4e5a-8d9a-6bdad65c0eaa.png)


Còn hàm `sub_40291C()` thực hiện `xor` từng giá trị `flag` với các giá trị của `v3` => `str`

![image](https://user-images.githubusercontent.com/87138860/224785463-7d0af1ba-74a1-4873-85ae-d9efba039316.png)

Sau khi có `str` chương trình sẽ so sánh với `dword_403040`.

Vậy để tìm được `flag` ta chỉ cần lấy giá trị của `dword_403040` `xor` với `v3`.


# Script

```python
stinh=[0x0C,0x46,0x9F,0x4B,0x77,0xC9,0x62,0xBB,0x42,0x0D,0xDD,0xA1,0xD3,0x22,0x33,0x6C,0x83,0x89,0x4A,0xE2,
0x7D,0xC9,0x06,0x39,0x34,0x22,0x82,0x61,0x54,0x3B,0x47,0xD8,0xF7,0x5C,0x30,0x21,0x02,0xAA,0x62,0x89,
0x0A,0x4E,0x6F,0xCF,0x62]
v3=[0xA3,0x45,0xCE,0x09,0xA0,0x80,0x36,0x87,0xF2,0x8C,0x15,0x0B,0xD3,0x1B,0xE4,0x7A,0xAF,0xD1,0x57,0xBF,
0x5A,0x27,0x85,0x2D,0x6A,0x5B,0xBD,0xE2,0xC4,0x24,0x00,0x62,0x42,0x68,0xA5,0xB3,0x55,0xC3,0x0F,0xBA,
0x47,0x37,0x20,0x9A,0x39,0x66,0x9C,0x3F,0xC5,0x4E,0x79,0x6F,0x65,0x64,0x83,0xC1,0xBC,0x21,0x7E,0x16,
0x51,0xFD,0x9E,0x5D,0x03,0x2B,0xDC,0xAA,0xEC,0xE3,0xAC,0x04,0x4A,0x13,0xB4,0xDD,0x10,0x70,0x34,0xAD,
0x3E,0x3A,0xC6,0x8D,0x5C,0x97,0xD2,0xB7,0x7C,0x6E,0x61,0x93,0x14,0x95,0xF4,0x4B,0x8A,0xA7,0x8E,0xED,
0x19,0x8F,0x96,0xDF,0x91,0x9F,0xB8,0x50,0x46,0x88,0xB5,0x53,0xE5,0xCA,0x4C,0xE6,0x76,0x72,0xF5,0x0A,
0x01,0xFA,0x44,0x74,0xD6,0x5F,0x18,0xA6,0x89,0xD8,0x9D,0x11,0x3D,0xF1,0xC7,0x1C,0xBE,0x2E,0x49,0xC2,
0x25,0x05,0x59,0xA9,0x75,0x90,0x31,0xDE,0x0E,0x92,0x1D,0x58,0x35,0xFB,0xF8,0xE8,0x98,0x94,0x6C,0xC9,
0x1F,0x40,0x7D,0xD7,0xE0,0xF9,0xD4,0x82,0x23,0x2C,0x4F,0x86,0x2A,0x81,0x32,0xDB,0xEE,0x84,0xFC,0x8B,
0xCB,0x02,0xDA,0x28,0x3B,0xF6,0x22,0xA1,0x2F,0x1A,0xB2,0x30,0x54,0x17,0x38,0xB1,0xF7,0x69,0xC0,0xF3,
0xCD,0xFF,0x0D,0x78,0xD0,0xCC,0x7F,0x08,0x26,0x0C,0x60,0x6D,0xE1,0xA8,0xCF,0x41,0xB0,0x73,0x29,0x71,
0xE7,0xFE,0xBB,0xB9,0x33,0x48,0x43,0xAE,0x52,0x06,0xC8,0xE9,0x1E,0x12,0x3C,0x7B,0x63,0xEA,0x99,0xD5,
0xEF,0xA2,0xB6,0x67,0xEB,0x56,0xD9,0xAB,0x6B,0xF0,0x5E,0x07,0xA4,0x4D,0x77,0x9B]
flag=[]
v7=0
v6=0
for i in range(45):
   v7 = ( v7 + 1) % 256
   v6 = ( v3[v7] + v6 ) % 256
   v5= v3[v7]
   v3[v7] = v3[v6]
   v3[v6] = v5
   flag.append( stinh[i] ^ v3[( v3[v7] + v3[v6] ) % 256])
   print(chr(flag[i]),end="")
   
   ```
   
   # Flag
   
   `KCSC{Th3_s0ck3t_1s_v3ry_fun_1n_b4s1c_m4lw4r3}`
